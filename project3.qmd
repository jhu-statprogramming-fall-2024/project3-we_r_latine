---
title: "project3"
format: html
editor: visual
---

## Project 3

Team Members:

-   Mateo Bandala Jacques \| abandal1\@jh.edu

-   María Camila Restrepo \| mrestre\@jh.edu

# Setup

```{r}
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("DBI")) install.packages("DBI")
if(!require("RSQLite")) install.packages("RSQLite")
if(!require("caret")) install.packages("caret")
if(!require("nycflights13")) install.packages("nycflights13")
if(!require("car")) install.packages("car")
if(!require("Metrics")) install.packages("Metrics")
  
library(tidyverse)
library(DBI)
library(RSQLite)
library(caret)
library(nycflights13)
library(car)
library(Metrics)


```

::: callout-note
## For our project, we will be using the NYC flights data
:::

# Part 1

We will be using flight data from nycflight13

Question to investigate:

Which airline had the most delay in 2013 in hours and in number of flights?
And is there a relationship between delays and weather in every airline?

1. If it’s already a SQL database, read into R using the DBI and RSQLite packages. If it’s not already a SQL database, create a new SQL database and use the dbWriteTable() function to add at minimum three tables to the SQL database.

```{r}

nyc_flights <- flights
nyc_airlines <- airlines
nyc_weather <- weather

# Create a connection to an SQLite database
con <- dbConnect(RSQLite::SQLite(), "nycflights13.db")

dbWriteTable(con, "nyc_flights", nyc_flights)
dbWriteTable(con, "nyc_airlines", nyc_airlines)
dbWriteTable(con, "nyc_weather", weather)

dbListTables(con) #all three tables are there

```

2. Write three SQL queries using dbGetQuery() to explore and summarize the data. You must use at least five different SQL functions (e.g. SELECT, GROUP BY, DISTINCT, SUM, etc).  

```{r}
#number of flights by origin

dbGetQuery(con, "SELECT origin, COUNT(*) AS num_flights FROM nyc_flights GROUP BY origin")

#Delay

dbGetQuery(con, "SELECT AVG(dep_delay) FROM nyc_flights")

#delay by airline

dbGetQuery(con, "SELECT carrier, AVG(dep_delay) 
           FROM nyc_flights 
           GROUP BY carrier
           ORDER BY AVG(dep_delay) DESC")

#weather: precipitation and visibility

dbGetQuery(con, "SELECT visib, AVG(visib), MIN(visib), MAX(visib)
           FROM nyc_weather")

dbGetQuery(con, "SELECT precip, AVG(precip), MIN(precip), MAX(precip)
           FROM nyc_weather")

```


List of SQL functions used:

- COUNT
- AVG
- MIN
- MAX
- GROUP BY
- ORDER BY

3. Write two SQL queries to create new features from existing data.  

```{r}
#Change precipitation and visibility into the international standard

#Precipitation from inches to mm
dbExecute(con, "ALTER TABLE nyc_weather 
          ADD COLUMN precip_mm NUMERIC")
dbExecute(con, "UPDATE nyc_weather 
          SET precip_mm = precip * 25.4")

#Visibility from miles to km
dbExecute(con, "ALTER TABLE nyc_weather 
          ADD COLUMN visib_km NUMERIC")
dbExecute(con, "UPDATE nyc_weather 
          SET visib_km = visib * 1.60934")

dbListFields(con, "nyc_weather")

#how did that change the values
dbGetQuery(con, "SELECT visib_km, AVG(visib_km), MIN(visib_km), MAX(visib_km)
           FROM nyc_weather")

dbGetQuery(con, "SELECT precip_mm, AVG(precip_mm), MIN(precip_mm), MAX(precip_mm)
           FROM nyc_weather")

#Merge the name of the airlines, precipitation and visibility

dbGetQuery(con, "SELECT COUNT(*) FROM nyc_flights")

merged <- dbGetQuery(con, "
    SELECT f.*, w.precip_mm, w.visib_km
    FROM nyc_flights AS f
    INNER JOIN nyc_weather AS w
    ON f.time_hour = w.time_hour
")
nrow(merged) #we have more rows than expected so we need to check why

dbGetQuery(con, "SELECT time_hour, COUNT(*) 
           FROM nyc_weather 
           GROUP BY time_hour HAVING COUNT(*) > 1
           ORDER BY COUNT(*) ASC") 

#most of them have a count of 3 and this is because of the 3 different origins. So we need to update our dataset. Some of them only have two which means that they don't have weather data on some airports

merged <- dbGetQuery(con, "
    SELECT f.*, w.precip_mm, w.visib_km
    FROM nyc_flights AS f
    INNER JOIN nyc_weather AS w
    ON f.time_hour = w.time_hour AND f.origin = w.origin
")

nrow(merged) #it seems that some flights were not matched, as the observations decreased from 336776 to 335220

merged <- merged %>%
  right_join(nyc_airlines, by = "carrier") %>%
   rename(
    precip = precip_mm,
    visib = visib_km
  )

```

4. Visualize your data by creating a plot with ggplot2. For example, if using nycflights13, you could think about how to visualize delays by month, carrier, or weather conditions.

5. Report your findings. Provide a paragraph summarizing your methods and key findings. Include any limitations or potential biases in your analysis. Be sure to comment and organize your code so is easy to understand what you are doing.

# Part 2

```{r}

nyc_flights <- flights

#Add weather!
nyc_flights <- flights %>%
  left_join(weather, by = c("year", "month", "day", "hour", "origin"))

#Our outcome of interest will be "ARRIVAL DELAY"

#Let's look at a simple boxplot of arrival delay
nyc_flights %>%
  filter(!is.na(arr_delay)) %>%
  slice_sample(n=1000)%>%
  ggplot(aes(x=arr_delay)) +
  scale_x_continuous(limits = c(0,200)) +
  geom_vline(xintercept = 30, color="red")+  #Maybe we could consider a cut-ff of 30 if we decide to go binary
  geom_bar() +
  labs(x="Departure delay", y="Count", title = "Histogram of arrival delay",
       subtitle = "NYC, 2013", caption = "Random sample of 1,000 flights")


#First, split the data into training and testing set

#Set seed
set.seed(89631139) 


#Keep only those rows with outcome data (arrival delay)
nyc_flights <- nyc_flights %>% filter(!is.na(arr_delay))

# Create partition indices (7 to 3)


train_index <- createDataPartition(nyc_flights$arr_delay, p = 0.7, list = FALSE)

# Split the data
train_data <- nyc_flights[train_index, ]
test_data <- nyc_flights[-train_index, ]

dim(train_data)
dim(test_data) #Looks good 





```

::: callout-note
## First, we will select which predictors to include by using Recursive Feature Elimination
:::

```{r}

#Let's use linear model, 5k crossvalidation
control <- rfeControl(functions = lmFuncs, method = "cv", number = 5)

# Perform RFE using some prespecified predictors
#Departure delay (obvious), distance,  Temperature, precipitation, and  wind speed

rfe_results <- rfe(
  train_data[, c("dep_delay", "distance", "temp", "precip", "wind_speed")], # Predictors
  train_data$arr_delay,                                # Outcome
  sizes = c(1:5),                                      # Test with 1 up to 5 predictors
  rfeControl = control #using linear regression with 5-fold cross validation
)

# View the optimal predictors
print(rfe_results)  #Using all 5 predictors has the lowest mean squared errors

# Plot RFE results

rfe_results %>%
  ggplot() +
  labs(x="Number of variables", y = "RMSE by CV",
       title = "Results of RFE", subtitle = "Using linear regression with 5 fold CV",
       caption  = "Model favours using all 5 variables")




```

::: callout-note
## Now let's train the model
:::

```{r}
#these are our optimal variables: 
optimal_predictors <- rfe_results$optVariables


#Let's fir a linear regression
formula <- as.formula(paste("arr_delay ~", paste(optimal_predictors, collapse = " + ")))
lm_model <- lm(formula, data = train_data)

#Let's look at the model output

summary(lm_model)

vif(lm_model) #There seems to be no issues with colinearity 




#Let's test the model

#First evaluate missingness
test_data %>%
  summarise(across(
    all_of(c("arr_delay", "dep_delay", "distance", "temp", "precip", "wind_speed")), 
    ~ sum(is.na(.)), 
    .names = "missing_{.col}"
  ))

# A small porportion of predictors are missingm we will simply get rid of them for now
test_data <- test_data %>%
  filter(if_all(
    all_of(c("arr_delay", "dep_delay", "distance", "temp", "precip", "wind_speed")), 
    ~ !is.na(.)
  ))

#now the prediction proper 

test_predictions <- predict(lm_model, newdata = test_data)




# Evaluate model performance

rmse_value <- rmse(test_data$arr_delay, test_predictions)
mae_value <- mae(test_data$arr_delay, test_predictions)
r_squared <- cor(test_data$arr_delay, test_predictions)^2

# Print metrics
cat("RMSE:", rmse_value, "\n") #this was 17.84 in the training set
cat("MAE:", mae_value, "\n")  #This was13 in the trainign set 
cat("R-squared:", r_squared, "\n") #this was 84 in the training set



ggplot(data = test_data, aes(x = test_predictions, y = arr_delay)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  ggtitle("Actual vs Predicted Arrival Delays") +
  xlab("Predicted Arrival Delay") +
  ylab("Actual Arrival Delay")


```
